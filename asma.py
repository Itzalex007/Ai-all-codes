# -*- coding: utf-8 -*-
"""Asma.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gGzcnFwYnjfv9XRJdzXPshxB_D961TO2
"""

from queue import PriorityQueue

# Define a simple board with obstacles
board = [
    [0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0]
]

# Define start and end points
start = (0, 0)
end = (4, 4)

# Define a function to calculate heuristic (Manhattan distance)
def heuristic(p1, p2):
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

# Define the A* algorithm
def A_star(board, start, end):
    # Define the priority queue
    pq = PriorityQueue()
    pq.put((0, start))
    
    # Define the visited set and the path dictionary
    visited = set()
    path = {}
    
    # Define the cost dictionary with the start node having cost 0
    cost = {start: 0}
    
    while not pq.empty():
        # Get the current node from the queue
        current = pq.get()[1]
        
        # If we have reached the end node, construct the path and return it
        if current == end:
            final_path = []
            while current in path:
                final_path.append(current)
                current = path[current]
            final_path.append(start)
            final_path.reverse()
            return final_path
        
        # Mark the current node as visited
        visited.add(current)
        
        # Loop through the neighbors and calculate the cost and heuristic
        for neighbor in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            neighbor_pos = (current[0] + neighbor[0], current[1] + neighbor[1])
            
            # If the neighbor is not on the board, skip it
            if neighbor_pos[0] < 0 or neighbor_pos[0] >= len(board) or neighbor_pos[1] < 0 or neighbor_pos[1] >= len(board[0]):
                continue
            
            # If the neighbor is an obstacle, skip it
            if board[neighbor_pos[0]][neighbor_pos[1]] == 1:
                continue
            
            # Calculate the cost to reach the neighbor from the current node
            new_cost = cost[current] + 1
            
            # If we have not visited the neighbor or the new cost is lower than the previous cost
            if neighbor_pos not in cost or new_cost < cost[neighbor_pos]:
                cost[neighbor_pos] = new_cost
                priority = new_cost + heuristic(end, neighbor_pos)
                pq.put((priority, neighbor_pos))
                path[neighbor_pos] = current
    
    # If there is no path, return None
    return None

# Test the A* algorithm
path = A_star(board, start, end)
if path is None:
    print("No path found.")
else:
    print("Path found:", path)

}